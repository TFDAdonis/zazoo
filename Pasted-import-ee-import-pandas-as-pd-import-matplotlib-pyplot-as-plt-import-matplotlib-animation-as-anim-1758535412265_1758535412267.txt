import ee
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib import dates as mdates
from datetime import datetime
from IPython.display import HTML, display, Image
import ipywidgets as widgets
import folium
from branca.element import Figure
from io import StringIO
import requests
from folium.plugins import Draw
from ipywidgets import Layout
from IPython.display import clear_output

# Initialize Earth Engine
try:
    ee.Authenticate()
except:
    pass  # Skip if already authenticated

try:
    ee.Initialize(project='citric-hawk-457513-i6')
    print("✅ Earth Engine initialized successfully!")
except Exception as e:
    print("❌ Error initializing Earth Engine:", str(e))
    raise

# FAO GAUL Dataset
FAO_GAUL = ee.FeatureCollection("FAO/GAUL/2015/level0")  # Countries
FAO_GAUL_ADMIN1 = ee.FeatureCollection("FAO/GAUL/2015/level1")  # Admin1 (states/provinces)
FAO_GAUL_ADMIN2 = ee.FeatureCollection("FAO/GAUL/2015/level2")  # Admin2 (municipalities)

# 1. STUDY AREA SELECTION
def get_admin_boundaries(level, country_code=None, admin1_code=None):
    """Get administrative boundaries at different levels"""
    if level == 0:  # Countries
        return FAO_GAUL
    elif level == 1:  # Admin1 (states/provinces)
        if country_code:
            return FAO_GAUL_ADMIN1.filter(ee.Filter.eq('ADM0_CODE', country_code))
        return FAO_GAUL_ADMIN1
    elif level == 2:  # Admin2 (municipalities)
        if admin1_code:
            return FAO_GAUL_ADMIN2.filter(ee.Filter.eq('ADM1_CODE', admin1_code))
        return FAO_GAUL_ADMIN2
    return None

def get_boundary_names(fc, level):
    """Get names of boundaries in a feature collection for a specific level"""
    try:
        if level == 0:  # Countries
            names = fc.aggregate_array('ADM0_NAME').getInfo()
        elif level == 1:  # Admin1 (states/provinces)
            names = fc.aggregate_array('ADM1_NAME').getInfo()
        elif level == 2:  # Admin2 (municipalities)
            names = fc.aggregate_array('ADM2_NAME').getInfo()
        else:
            names = []
        return sorted(list(set(names)))  # Remove duplicates and sort
    except Exception as e:
        print(f"Error getting boundary names: {str(e)}")
        return []

# 2. CLOUD MASKING AND VEGETATION INDICES FUNCTIONS
def mask_clouds(image):
    qa = image.select('QA60')
    cloud_mask = qa.bitwiseAnd(1 << 10).eq(0)
    cirrus_mask = qa.bitwiseAnd(1 << 11).eq(0)
    return image.updateMask(cloud_mask.And(cirrus_mask))

def add_vegetation_indices(image):
    # NDVI - Normalized Difference Vegetation Index
    ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')
    
    # ARVI - Atmospherically Resistant Vegetation Index
    arvi = image.expression(
        '(NIR - (2 * RED - BLUE)) / (NIR + (2 * RED - BLUE))', {
            'NIR': image.select('B8'),
            'RED': image.select('B4'),
            'BLUE': image.select('B2')
        }).rename('ARVI')
    
    # ATSAVI - Adjusted Transformed Soil-Adjusted Vegetation Index
    atsavi = image.expression(
        'a * (NIR - a * RED - b) / (a * NIR + RED - a * b + X * (1 + a * a))', {
            'NIR': image.select('B8'),
            'RED': image.select('B4'),
            'a': 1.22,
            'b': 0.03,
            'X': 0.08
        }).rename('ATSAVI')
    
    # DVI - Difference Vegetation Index
    dvi = image.expression('NIR - RED', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('DVI')
    
    # EVI - Enhanced Vegetation Index
    evi = image.expression(
        '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
            'NIR': image.select('B8'),
            'RED': image.select('B4'),
            'BLUE': image.select('B2')
        }).rename('EVI')
    
    # EVI2 - Two-band Enhanced Vegetation Index
    evi2 = image.expression(
        '2.5 * (NIR - RED) / (NIR + 2.4 * RED + 1)', {
            'NIR': image.select('B8'),
            'RED': image.select('B4')
        }).rename('EVI2')
    
    # GNDVI - Green Normalized Difference Vegetation Index
    gndvi = image.normalizedDifference(['B8', 'B3']).rename('GNDVI')
    
    # MSAVI - Modified Soil-Adjusted Vegetation Index
    msavi = image.expression(
        '(2 * NIR + 1 - sqrt((2 * NIR + 1)**2 - 8 * (NIR - RED))) / 2', {
            'NIR': image.select('B8'),
            'RED': image.select('B4')
        }).rename('MSAVI')
    
    # MSI - Moisture Stress Index
    msi = image.expression('SWIR1 / NIR', {
        'SWIR1': image.select('B11'),
        'NIR': image.select('B8')
    }).rename('MSI')
    
    # MTVI - Modified Triangular Vegetation Index
    mtvi = image.expression(
        '1.2 * (1.2 * (NIR - GREEN) - 2.5 * (RED - GREEN))', {
            'NIR': image.select('B8'),
            'RED': image.select('B4'),
            'GREEN': image.select('B3')
        }).rename('MTVI')
    
    # MTVI2 - Modified Triangular Vegetation Index 2
    mtvi2 = image.expression(
        '(1.5 * (1.2 * (NIR - GREEN) - 2.5 * (RED - GREEN)) / ' +
        'sqrt((2 * NIR + 1)**2 - (6 * NIR - 5 * sqrt(RED)) - 0.5))', {
            'NIR': image.select('B8'),
            'RED': image.select('B4'),
            'GREEN': image.select('B3')
        }).rename('MTVI2')
    
    # NDTI - Normalized Difference Tillage Index
    ndti = image.normalizedDifference(['B11', 'B12']).rename('NDTI')
    
    # NDWI - Normalized Difference Water Index
    ndwi = image.normalizedDifference(['B3', 'B8']).rename('NDWI')
    
    # OSAVI - Optimized Soil-Adjusted Vegetation Index
    osavi = image.expression('(NIR - RED) / (NIR + RED + 0.16)', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('OSAVI')
    
    # RDVI - Renormalized Difference Vegetation Index
    rdvi = image.expression('(NIR - RED) / sqrt(NIR + RED)', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('RDVI')
    
    # RI - Redness Index
    ri = image.expression('RED / GREEN', {
        'RED': image.select('B4'),
        'GREEN': image.select('B3')
    }).rename('RI')
    
    # RVI - Ratio Vegetation Index
    rvi = image.expression('NIR / RED', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('RVI')
    
    # SAVI - Soil-Adjusted Vegetation Index
    savi = image.expression('1.5 * (NIR - RED) / (NIR + RED + 0.5)', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('SAVI')
    
    # TVI - Triangular Vegetation Index
    tvi = image.expression('0.5 * (120 * (NIR - GREEN) - 200 * (RED - GREEN))', {
        'NIR': image.select('B8'),
        'RED': image.select('B4'),
        'GREEN': image.select('B3')
    }).rename('TVI')
    
    # TSAVI - Transformed Soil-Adjusted Vegetation Index
    tsavi = image.expression(
        '(a * (NIR - a * RED - b)) / (RED + a * (NIR - b) + X * (1 + a * a))', {
            'NIR': image.select('B8'),
            'RED': image.select('B4'),
            'a': 1.22,
            'b': 0.03,
            'X': 0.08
        }).rename('TSAVI')
    
    # VARI - Visible Atmospherically Resistant Index
    vari = image.expression('(GREEN - RED) / (GREEN + RED - BLUE)', {
        'GREEN': image.select('B3'),
        'RED': image.select('B4'),
        'BLUE': image.select('B2')
    }).rename('VARI')
    
    # VIN - Vegetation Index based on NIR and Red
    vin = image.expression('NIR - RED', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('VIN')
    
    # WDRVI - Wide Dynamic Range Vegetation Index
    wdrvi = image.expression('(0.1 * NIR - RED) / (0.1 * NIR + RED)', {
        'NIR': image.select('B8'),
        'RED': image.select('B4')
    }).rename('WDRVI')
    
    # GCVI - Green Chlorophyll Vegetation Index
    gcvi = image.expression('(NIR / GREEN) - 1', {
        'NIR': image.select('B8'),
        'GREEN': image.select('B3')
    }).rename('GCVI')
    
    # AWEI - Automated Water Extraction Index
    aweinsh = image.expression('4 * (GREEN - SWIR1) - (0.25 * NIR + 2.75 * SWIR2)', {
        'GREEN': image.select('B3'),
        'SWIR1': image.select('B11'),
        'NIR': image.select('B8'),
        'SWIR2': image.select('B12')
    }).rename('AWEI')
    
    # MNDWI - Modified Normalized Difference Water Index
    mndwi = image.normalizedDifference(['B3', 'B11']).rename('MNDWI')
    
    # WI - Water Index
    wi = image.expression('GREEN / NIR', {
        'GREEN': image.select('B3'),
        'NIR': image.select('B8')
    }).rename('WI')
    
    # ANDWI - Automated Water Extraction Index with no shadows
    andwi = image.expression('(GREEN + 2.5 * RED - 1.5 * (NIR + SWIR1) - 0.25 * SWIR2)', {
        'GREEN': image.select('B3'),
        'RED': image.select('B4'),
        'NIR': image.select('B8'),
        'SWIR1': image.select('B11'),
        'SWIR2': image.select('B12')
    }).rename('ANDWI')
    
    # NDSI - Normalized Difference Snow Index
    ndsi = image.normalizedDifference(['B3', 'B11']).rename('NDSI')
    
    # nDDI - Normalized Difference Drought Index
    nddi = image.expression('(NDVI - NDWI) / (NDVI + NDWI)', {
        'NDVI': ndvi,
        'NDWI': ndwi
    }).rename('nDDI')
    
    # NBR - Normalized Burn Ratio
    nbr = image.normalizedDifference(['B8', 'B12']).rename('NBR')
    
    # DBSI - Dry Bareness Soil Index
    dbsi = image.expression('(SWIR1 - NIR) / (SWIR1 + NIR)', {
        'SWIR1': image.select('B11'),
        'NIR': image.select('B8')
    }).rename('DBSI')
    
    # SI - Salinity Index
    si = image.expression('(BLUE * RED)**0.5', {
        'BLUE': image.select('B2'),
        'RED': image.select('B4')
    }).rename('SI')
    
    # S3 - Salinity Index 3
    s3 = image.expression('(RED * SWIR1)**0.5', {
        'RED': image.select('B4'),
        'SWIR1': image.select('B11')
    }).rename('S3')
    
    # BRI - Brightness Index
    bri = image.expression('(RED * GREEN)**0.5', {
        'RED': image.select('B4'),
        'GREEN': image.select('B3')
    }).rename('BRI')
    
    # SSI - Soil Salinity Index
    ssi = image.expression('(SWIR1 / RED)', {
        'SWIR1': image.select('B11'),
        'RED': image.select('B4')
    }).rename('SSI')
    
    # NDSI_Salinity - Normalized Difference Salinity Index
    ndsi_salinity = image.normalizedDifference(['B3', 'B11']).rename('NDSI_Salinity')
    
    # SRPI - Simple Ratio Pigment Index
    srpi = image.expression('RED / BLUE', {
        'RED': image.select('B4'),
        'BLUE': image.select('B2')
    }).rename('SRPI')
    
    # MCARI - Modified Chlorophyll Absorption in Reflectance Index
    mcari = image.expression(
        '((RE1 - RED) - 0.2 * (RE1 - GREEN)) * (RE1 / RED)', {
            'RE1': image.select('B5'),
            'RED': image.select('B4'),
            'GREEN': image.select('B3')
        }).rename('MCARI')
    
    # NDCI - Normalized Difference Chlorophyll Index
    ndci = image.normalizedDifference(['B5', 'B4']).rename('NDCI')
    
    # PSSRb1 - Pigment Specific Simple Ratio (Chlorophyll b)
    pssrb1 = image.expression('NIR / GREEN', {
        'NIR': image.select('B8'),
        'GREEN': image.select('B3')
    }).rename('PSSRb1')
    
    # SIPI - Structure Intensive Pigment Index
    sipi = image.expression('(NIR - BLUE) / (NIR - RED)', {
        'NIR': image.select('B8'),
        'BLUE': image.select('B2'),
        'RED': image.select('B4')
    }).rename('SIPI')
    
    # PSRI - Plant Senescence Reflectance Index
    psri = image.expression('(RED - BLUE) / RE2', {
        'RED': image.select('B4'),
        'BLUE': image.select('B2'),
        'RE2': image.select('B6')
    }).rename('PSRI')
    
    # Chl_red_edge - Chlorophyll Red Edge Index
    chl_red_edge = image.expression('NIR / RE1 - 1', {
        'NIR': image.select('B8'),
        'RE1': image.select('B5')
    }).rename('Chl_red_edge')
    
    # MARI - Modified Anthocyanin Reflectance Index
    mari = image.expression('(1 / GREEN) - (1 / RE1)', {
        'GREEN': image.select('B3'),
        'RE1': image.select('B5')
    }).rename('MARI')
    
    # NDMI - Normalized Difference Moisture Index
    ndmi = image.normalizedDifference(['B8', 'B11']).rename('NDMI')
    
    # Add all indices to the image
    return image.addBands([
        ndvi, arvi, atsavi, dvi, evi, evi2, gndvi, msavi, msi, mtvi, mtvi2,
        ndti, ndwi, osavi, rdvi, ri, rvi, savi, tvi, tsavi, vari, vin, wdrvi,
        gcvi, aweinsh, mndwi, wi, andwi, ndsi, nddi, nbr, dbsi, si, s3, bri,
        ssi, ndsi_salinity, srpi, mcari, ndci, pssrb1, sipi, psri, chl_red_edge,
        mari, ndmi
    ])

# 3. AUTOMATIC GIF GENERATION
def generate_ndvi_gif(study_roi, index_name='NDVI', start_date='2023-01-01', end_date='2023-03-01'):
    # Create monthly composites
    def create_monthly_composite(date):
        date = ee.Date(date)
        monthly_image = (ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                      .filterBounds(study_roi)
                      .filterDate(date, date.advance(1, 'month'))
                      .map(mask_clouds)
                      .map(add_vegetation_indices)
                      .median()
                      .clip(study_roi))
        return monthly_image.set('system:time_start', date.millis())

    # Generate sequence of months
    n_months = ee.Date(end_date).difference(ee.Date(start_date), 'month').round()
    dates = ee.List.sequence(0, n_months).map(
        lambda n: ee.Date(start_date).advance(n, 'month'))

    collection = ee.ImageCollection(dates.map(create_monthly_composite))

    # GIF parameters
    vis_params = {
        'min': 0.0,
        'max': 1.0,
        'palette': ['red', 'yellow', 'green', 'darkgreen'],
        'bands': [index_name],
        'region': study_roi,
        'dimensions': 600,
        'framesPerSecond': 2,
        'format': 'gif'
    }

    try:
        print(f"🔄 Generating {index_name} timelapse GIF...")
        gif_url = collection.getVideoThumbURL(vis_params)
        display(Image(url=gif_url))
        print(f"✅ {index_name} GIF generated successfully! Right-click to save.")
    except Exception as e:
        print(f"❌ Error generating {index_name} GIF:", str(e))

# 4. CUSTOM DATA PROCESSING
def analyze_custom_data(data_input):
    df = pd.read_csv(StringIO(data_input), header=None, names=['date', 'NDVI'])
    df['date'] = pd.to_datetime(df['date'])
    df = df.sort_values('date').dropna()

    # Create animation
    fig, ax = plt.subplots(figsize=(12, 6))

    def animate(i):
        ax.clear()
        current_date = df['date'].iloc[i]
        mask = df['date'] <= current_date

        ax.scatter(df[mask]['date'], df[mask]['NDVI'],
                 color='green', alpha=0.7, s=50, label='Your Data')
        ax.set_title(f'Your NDVI Measurements\n{current_date.strftime("%Y-%m-%d")}')
        ax.set_ylabel('NDVI Value')
        ax.set_xlabel('Date')
        ax.set_ylim(-0.5, 1.0)
        ax.legend()
        ax.grid(True, alpha=0.3)
        plt.xticks(rotation=45)
        plt.tight_layout()

    ani = animation.FuncAnimation(fig, animate, frames=len(df), interval=200)
    plt.close(fig)
    return HTML(ani.to_jshtml())

# 5. VEGETATION INDEX TIME SERIES ANALYSIS (NEW FUNCTION)
def analyze_vi_timeseries(study_roi, index_name='NDVI', start_date='2020-01-01', end_date=None):
    """Generate vegetation index time series charts for the selected region"""
    try:
        # Get a representative point from the ROI
        centroid = study_roi.centroid()
        
        # Use provided end date or current date
        if end_date is None:
            end_date = datetime.now().strftime('%Y-%m-%d')
        
        # Cloud masking function
        def maskS2clouds(image):
            qa = image.select('QA60')
            cloudBitMask = 1 << 10
            cirrusBitMask = 1 << 11
            mask = qa.bitwiseAnd(cloudBitMask).eq(0).And(
                   qa.bitwiseAnd(cirrusBitMask).eq(0))
            return image.updateMask(mask)

        # Data collection
        collection = (ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                      .filterBounds(study_roi)
                      .filterDate(start_date, end_date)
                      .map(maskS2clouds)
                      .map(add_vegetation_indices))

        # Daily processing
        daily_vi = ee.ImageCollection(collection.map(lambda image:
            image.select(index_name).set('system:time_start', image.date().millis())))

        # Time series analysis
        print(f"🔄 Generating {index_name} time series data for {start_date} to {end_date}...")
        timeseries = daily_vi.getRegion(centroid, 10).getInfo()

        # Data processing
        df = pd.DataFrame(timeseries[1:], columns=timeseries[0])
        df['datetime'] = pd.to_datetime(df['time'], unit='ms')
        df[index_name] = pd.to_numeric(df[index_name])
        df = df.dropna(subset=[index_name])
        df = df.set_index('datetime')[index_name]
        
        # Create visualizations
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10))
        
        # Daily time series
        df.plot(ax=ax1, title=f'Daily {index_name} Time Series ({start_date} to {end_date})', ylabel=index_name, alpha=0.7)
        ax1.grid(True, alpha=0.3)
        
        # Monthly averages
        monthly_mean = df.resample('M').mean()
        monthly_mean.plot(ax=ax2, title=f'Monthly Mean {index_name}', ylabel=index_name, color='green')
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        # Display statistics
        print(f"📊 {index_name} Statistics for the region ({start_date} to {end_date}):")
        print(f"   Mean {index_name}: {monthly_mean.mean():.3f}")
        print(f"   Max {index_name}: {monthly_mean.max():.3f}")
        print(f"   Min {index_name}: {monthly_mean.min():.3f}")
        print(f"   Seasonal variation: {monthly_mean.max() - monthly_mean.min():.3f}")
        
    except Exception as e:
        print(f"❌ Error generating {index_name} time series: {str(e)}")

# 6. INTERACTIVE UI WITH BOUNDARY SELECTION
default_data = """2023-01-05,0.106
2023-01-05,0.225
2023-01-05,-0.161
2023-01-07,0.103
2023-01-07,0.174
2023-01-10,0.207
2023-01-10,-0.299
2023-01-15,0.109
2023-01-15,0.235"""

# Initialize country options
country_options = get_boundary_names(FAO_GAUL, level=0)

# Create boundary selection widgets
boundary_type = widgets.Dropdown(
    options=['Draw on Map', 'Country', 'Admin1 (State/Province)', 'Admin2 (Municipality)'],
    value='Country',
    description='Boundary Type:',
    style={'description_width': 'initial'}
)

country_dropdown = widgets.Dropdown(
    options=country_options,
    description='Country:',
    disabled=False,
    style={'description_width': 'initial'}
)

admin1_dropdown = widgets.Dropdown(
    options=[],
    description='State/Province:',
    disabled=True,
    style={'description_width': 'initial'}
)

admin2_dropdown = widgets.Dropdown(
    options=[],
    description='Municipality:',
    disabled=True,
    style={'description_width': 'initial'}
)

# Vegetation index selection
vi_options = [
    'NDVI', 'ARVI', 'ATSAVI', 'DVI', 'EVI', 'EVI2', 'GNDVI', 'MSAVI', 
    'MSI', 'MTVI', 'MTVI2', 'NDTI', 'NDWI', 'OSAVI', 'RDVI', 'RI', 
    'RVI', 'SAVI', 'TVI', 'TSAVI', 'VARI', 'VIN', 'WDRVI', 'GCVI', 
    'AWEI', 'MNDWI', 'WI', 'ANDWI', 'NDSI', 'nDDI', 'NBR', 'DBSI',
    'SI', 'S3', 'BRI', 'SSI', 'NDSI_Salinity', 'SRPI',
    'MCARI', 'NDCI', 'PSSRb1', 'SIPI', 'PSRI', 'Chl_red_edge', 'MARI', 'NDMI'
]

vi_dropdown = widgets.Dropdown(
    options=vi_options,
    value='NDVI',
    description='Vegetation Index:',
    style={'description_width': 'initial'}
)

# Date range widgets
start_date_picker = widgets.DatePicker(
    description='Start Date:',
    value=datetime(2023, 1, 1),
    style={'description_width': 'initial'}
)

end_date_picker = widgets.DatePicker(
    description='End Date:',
    value=datetime(2023, 3, 1),
    style={'description_width': 'initial'}
)

# Create a separate output for the map
map_output = widgets.Output()
with map_output:
    # Create Folium map
    m = folium.Map(location=[20, 0], zoom_start=2)
    # Add drawing tools
    Draw(export=True).add_to(m)
    display(m)

def update_country(change):
    if change['new']:
        try:
            # Get the country code for the selected country
            country_feature = FAO_GAUL.filter(ee.Filter.eq('ADM0_NAME', change['new'])).first()
            country_code = country_feature.get('ADM0_CODE').getInfo()

            # Get all admin1 regions for this country
            admin1_fc = get_admin_boundaries(level=1, country_code=country_code)
            admin1_options = get_boundary_names(admin1_fc, level=1)

            # Update dropdowns
            admin1_dropdown.options = admin1_options
            admin1_dropdown.disabled = len(admin1_options) == 0
            admin1_dropdown.value = None
            admin2_dropdown.options = []
            admin2_dropdown.disabled = True

            # Update the map to show the selected country
            with map_output:
                map_output.clear_output()
                m = folium.Map(location=[20, 0], zoom_start=2)
                country_geom = country_feature.geometry().getInfo()
                folium.GeoJson(country_geom,
                             style_function=lambda x: {'color': 'blue', 'fillOpacity': 0.1}).add_to(m)
                Draw(export=True).add_to(m)
                display(m)

        except Exception as e:
            print(f"Error updating country: {str(e)}")
            admin1_dropdown.options = []
            admin1_dropdown.disabled = True
            admin2_dropdown.options = []
            admin2_dropdown.disabled = True

def update_admin1(change):
    if change['new']:
        try:
            # Get the admin1 code for the selected region
            admin1_feature = FAO_GAUL_ADMIN1.filter(ee.Filter.eq('ADM1_NAME', change['new'])).first()
            admin1_code = admin1_feature.get('ADM1_CODE').getInfo()
            country_code = admin1_feature.get('ADM0_CODE').getInfo()

            # Get all admin2 regions for this admin1
            admin2_fc = get_admin_boundaries(level=2, admin1_code=admin1_code)
            admin2_options = get_boundary_names(admin2_fc, level=2)

            # Update dropdown
            admin2_dropdown.options = admin2_options
            admin2_dropdown.disabled = len(admin2_options) == 0
            admin2_dropdown.value = None

            # Update the map to show the selected admin1 region
            with map_output:
                map_output.clear_output()
                m = folium.Map(location=[20, 0], zoom_start=6)
                admin1_geom = admin1_feature.geometry().getInfo()
                folium.GeoJson(admin1_geom,
                             style_function=lambda x: {'color': 'green', 'fillOpacity': 0.2}).add_to(m)
                Draw(export=True).add_to(m)
                display(m)

        except Exception as e:
            print(f"Error updating admin1: {str(e)}")
            admin2_dropdown.options = []
            admin2_dropdown.disabled = True

country_dropdown.observe(update_country, names='value')
admin1_dropdown.observe(update_admin1, names='value')

def update_boundary_type(change):
    if change['new'] == 'Draw on Map':
        country_dropdown.disabled = True
        admin1_dropdown.disabled = True
        admin2_dropdown.disabled = True
    elif change['new'] == 'Country':
        country_dropdown.disabled = False
        admin1_dropdown.disabled = True
        admin2_dropdown.disabled = True
    elif change['new'] == 'Admin1 (State/Province)':
        country_dropdown.disabled = False
        admin1_dropdown.disabled = False
        admin2_dropdown.disabled = True
    elif change['new'] == 'Admin2 (Municipality)':
        country_dropdown.disabled = False
        admin1_dropdown.disabled = False
        admin2_dropdown.disabled = False

boundary_type.observe(update_boundary_type, names='value')

# Data input widget
data_input = widgets.Textarea(
    value=default_data,
    placeholder='Paste your NDVI data here (date,value)',
    layout=Layout(width='600px', height='200px')
)

output = widgets.Output()

def on_run_click(b):
    with output:
        output.clear_output()

        # Get selected boundary
        if boundary_type.value == 'Draw on Map':
            # Get drawn features from map
            try:
                drawn_features = m._children['draw'].last_draw
                if not drawn_features or 'geometry' not in drawn_features:
                    print("❌ Please draw a boundary on the map first!")
                    return
                study_roi = ee.Geometry(drawn_features['geometry'])
                selected_name = "Custom Drawn Area"
            except Exception as e:
                print(f"❌ Error getting drawn features: {str(e)}")
                return
        else:
            if boundary_type.value == 'Country':
                if not country_dropdown.value:
                    print("❌ Please select a country first!")
                    return
                selected_name = country_dropdown.value
                study_roi = FAO_GAUL.filter(ee.Filter.eq('ADM0_NAME', selected_name)).geometry()
            elif boundary_type.value == 'Admin1 (State/Province)':
                if not admin1_dropdown.value:
                    print("❌ Please select a state/province first!")
                    return
                selected_name = admin1_dropdown.value
                study_roi = FAO_GAUL_ADMIN1.filter(ee.Filter.eq('ADM1_NAME', selected_name)).geometry()
            else:  # Admin2
                if not admin2_dropdown.value:
                    print("❌ Please select a municipality first!")
                    return
                selected_name = admin2_dropdown.value
                study_roi = FAO_GAUL_ADMIN2.filter(ee.Filter.eq('ADM2_NAME', selected_name)).geometry()

        # Get selected vegetation index
        selected_vi = vi_dropdown.value
        
        # Get date range
        start_date = start_date_picker.value.strftime('%Y-%m-%d')
        end_date = end_date_picker.value.strftime('%Y-%m-%d')

        # Show study area
        display(widgets.HTML(f"<h3>📍 Selected Area: {selected_name}</h3>"))
        display(widgets.HTML(f"<h4>📅 Date Range: {start_date} to {end_date}</h4>"))
        display(widgets.HTML(f"<h4>🌿 Vegetation Index: {selected_vi}</h4>"))

        # Create a new map to display the selected area
        with map_output:
            map_output.clear_output()
            m2 = folium.Map(location=[20, 0], zoom_start=2)
            folium.GeoJson(study_roi.getInfo(),
                          style_function=lambda x: {'color': 'green', 'fillOpacity': 0.2}).add_to(m2)
            display(m2)

        # Generate vegetation index time series analysis
        display(widgets.HTML(f"<h3>📈 {selected_vi} Time Series Analysis</h3>"))
        analyze_vi_timeseries(study_roi, selected_vi, start_date, end_date)

        # Generate satellite GIF
        display(widgets.HTML(f"<h3>🛰️ Satellite {selected_vi} Timelapse</h3>"))
        generate_ndvi_gif(study_roi, selected_vi, start_date, end_date)

        # Process custom data
        if data_input.value.strip():
            display(widgets.HTML("<h3>📊 Your NDVI Data Animation</h3>"))
            display(analyze_custom_data(data_input.value))

run_button = widgets.Button(
    description="Generate Visualizations",
    button_style='success',
    icon='satellite',
    layout=Layout(width='auto')
)

# Create the UI layout
ui = widgets.VBox([
    widgets.HTML("""<h1>Advanced Vegetation Index Analysis</h1>
    <p>Select administrative boundaries or draw custom area, then generate vegetation index visualizations</p>"""),
    widgets.HTML("<h3>Select Study Area:</h3>"),
    boundary_type,
    country_dropdown,
    admin1_dropdown,
    admin2_dropdown,
    widgets.HTML("<h4>Or draw custom boundary:</h4>"),
    map_output,
    widgets.HTML("<h3>Select Vegetation Index and Date Range:</h3>"),
    vi_dropdown,
    start_date_picker,
    end_date_picker,
    widgets.HTML("<h3>Enter Your NDVI Data (Optional):</h3>"),
    data_input,
    run_button,
    output
])

# Display the UI
display(ui)

# Set up button click handler
run_button.on_click(on_run_click)